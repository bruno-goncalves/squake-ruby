# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `net-http` gem.
# Please instead update this file by running `bin/tapioca gem net-http`.

# :enddoc:
class Net::HTTP < ::Net::Protocol
  # Creates a new Net::HTTP object for the specified server address,
  # without opening the TCP connection or initializing the HTTP session.
  # The +address+ should be a DNS hostname or IP address.
  #
  # @return [HTTP] a new instance of HTTP
  #
  # source://net-http//net/http.rb#830
  def initialize(address, port = T.unsafe(nil)); end

  # Returns true if the HTTP session has been started.
  #
  # @return [Boolean]
  #
  # source://net-http//net/http.rb#1101
  def active?; end

  # The DNS host name or IP address to connect to.
  #
  # source://net-http//net/http.rb#931
  def address; end

  # Sets path of a CA certification file in PEM format.
  #
  # The file can contain several CA certificates.
  #
  # source://net-http//net/http.rb#1164
  def ca_file; end

  # Sets path of a CA certification file in PEM format.
  #
  # The file can contain several CA certificates.
  #
  # source://net-http//net/http.rb#1164
  def ca_file=(_arg0); end

  # Sets path of a CA certification directory containing certifications in
  # PEM format.
  #
  # source://net-http//net/http.rb#1168
  def ca_path; end

  # Sets path of a CA certification directory containing certifications in
  # PEM format.
  #
  # source://net-http//net/http.rb#1168
  def ca_path=(_arg0); end

  # Sets an OpenSSL::X509::Certificate object as client certificate.
  # (This method is appeared in Michal Rokos's OpenSSL extension).
  #
  # source://net-http//net/http.rb#1172
  def cert; end

  # Sets an OpenSSL::X509::Certificate object as client certificate.
  # (This method is appeared in Michal Rokos's OpenSSL extension).
  #
  # source://net-http//net/http.rb#1172
  def cert=(_arg0); end

  # Sets the X509::Store to verify peer certificate.
  #
  # source://net-http//net/http.rb#1175
  def cert_store; end

  # Sets the X509::Store to verify peer certificate.
  #
  # source://net-http//net/http.rb#1175
  def cert_store=(_arg0); end

  # Sets the available ciphers.  See OpenSSL::SSL::SSLContext#ciphers=
  #
  # source://net-http//net/http.rb#1178
  def ciphers; end

  # Sets the available ciphers.  See OpenSSL::SSL::SSLContext#ciphers=
  #
  # source://net-http//net/http.rb#1178
  def ciphers=(_arg0); end

  # Returns the value of attribute close_on_empty_response.
  #
  # source://net-http//net/http.rb#1107
  def close_on_empty_response; end

  # Sets the attribute close_on_empty_response
  #
  # @param value the value to set the attribute close_on_empty_response to.
  #
  # source://net-http//net/http.rb#1107
  def close_on_empty_response=(_arg0); end

  # Seconds to wait for 100 Continue response. If the HTTP object does not
  # receive a response in this many seconds it sends the request body. The
  # default value is +nil+.
  #
  # source://net-http//net/http.rb#1082
  def continue_timeout; end

  # Setter for the continue_timeout attribute.
  #
  # source://net-http//net/http.rb#1085
  def continue_timeout=(sec); end

  # Sends a COPY request to the +path+ and gets a response,
  # as an HTTPResponse object.
  #
  # source://net-http//net/http.rb#1685
  def copy(path, initheader = T.unsafe(nil)); end

  # Sends a DELETE request to the +path+ and gets a response,
  # as an HTTPResponse object.
  #
  # source://net-http//net/http.rb#1673
  def delete(path, initheader = T.unsafe(nil)); end

  # Sets the extra X509 certificates to be added to the certificate chain.
  # See OpenSSL::SSL::SSLContext#extra_chain_cert=
  #
  # source://net-http//net/http.rb#1182
  def extra_chain_cert; end

  # Sets the extra X509 certificates to be added to the certificate chain.
  # See OpenSSL::SSL::SSLContext#extra_chain_cert=
  #
  # source://net-http//net/http.rb#1182
  def extra_chain_cert=(_arg0); end

  # Finishes the HTTP session and closes the TCP connection.
  # Raises IOError if the session has not been started.
  #
  # @raise [IOError]
  #
  # source://net-http//net/http.rb#1369
  def finish; end

  # Retrieves data from +path+ on the connected-to host which may be an
  # absolute path String or a URI to extract the path from.
  #
  # +initheader+ must be a Hash like { 'Accept' => '*/*', ... },
  # and it defaults to an empty hash.
  # If +initheader+ doesn't have the key 'accept-encoding', then
  # a value of "gzip;q=1.0,deflate;q=0.6,identity;q=0.3" is used,
  # so that gzip compression is used in preference to deflate
  # compression, which is used in preference to no compression.
  # Ruby doesn't have libraries to support the compress (Lempel-Ziv)
  # compression, so that is not supported.  The intent of this is
  # to reduce bandwidth by default.   If this routine sets up
  # compression, then it does the decompression also, removing
  # the header as well to prevent confusion.  Otherwise
  # it leaves the body as it found it.
  #
  # This method returns a Net::HTTPResponse object.
  #
  # If called with a block, yields each fragment of the
  # entity body in turn as a string as it is read from
  # the socket.  Note that in this case, the returned response
  # object will *not* contain a (meaningful) body.
  #
  # +dest+ argument is obsolete.
  # It still works but you must not use it.
  #
  # This method never raises an exception.
  #
  #     response = http.get('/index.html')
  #
  #     # using block
  #     File.open('result.txt', 'w') {|f|
  #       http.get('/~foo/') do |str|
  #         f.write str
  #       end
  #     }
  #
  # source://net-http//net/http.rb#1573
  def get(path, initheader = T.unsafe(nil), dest = T.unsafe(nil), &block); end

  # Sends a GET request to the +path+.
  # Returns the response as a Net::HTTPResponse object.
  #
  # When called with a block, passes an HTTPResponse object to the block.
  # The body of the response will not have been read yet;
  # the block can process it using HTTPResponse#read_body,
  # if desired.
  #
  # Returns the response.
  #
  # This method never raises Net::* exceptions.
  #
  #     response = http.request_get('/index.html')
  #     # The entity body is already read in this case.
  #     p response['content-type']
  #     puts response.body
  #
  #     # Using a block
  #     http.request_get('/index.html') {|response|
  #       p response['content-type']
  #       response.read_body do |str|   # read body now
  #         print str
  #       end
  #     }
  #
  # source://net-http//net/http.rb#1726
  def get2(path, initheader = T.unsafe(nil), &block); end

  # Gets only the header from +path+ on the connected-to host.
  # +header+ is a Hash like { 'Accept' => '*/*', ... }.
  #
  # This method returns a Net::HTTPResponse object.
  #
  # This method never raises an exception.
  #
  #     response = nil
  #     Net::HTTP.start('some.www.server', 80) {|http|
  #       response = http.head('/index.html')
  #     }
  #     p response['content-type']
  #
  # source://net-http//net/http.rb#1595
  def head(path, initheader = T.unsafe(nil)); end

  # Sends a HEAD request to the +path+ and returns the response
  # as a Net::HTTPResponse object.
  #
  # Returns the response.
  #
  # This method never raises Net::* exceptions.
  #
  #     response = http.request_head('/index.html')
  #     p response['content-type']
  #
  # source://net-http//net/http.rb#1740
  def head2(path, initheader = T.unsafe(nil), &block); end

  # Whether to ignore EOF when reading response bodies with defined
  # Content-Length headers. For backwards compatibility, the default is true.
  #
  # source://net-http//net/http.rb#1098
  def ignore_eof; end

  # Whether to ignore EOF when reading response bodies with defined
  # Content-Length headers. For backwards compatibility, the default is true.
  #
  # source://net-http//net/http.rb#1098
  def ignore_eof=(_arg0); end

  # Returns a string representation of +self+:
  #
  #   Net::HTTP.new(hostname).inspect
  #   # => "#<Net::HTTP jsonplaceholder.typicode.com:80 open=false>"
  #
  # source://net-http//net/http.rb#872
  def inspect; end

  # Returns the IP address for the connection.
  #
  # If the session has not been started,
  # returns the value set by #ipaddr=,
  # or +nil+ if it has not been set:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.ipaddr # => nil
  #   http.ipaddr = '172.67.155.76'
  #   http.ipaddr # => "172.67.155.76"
  #
  # If the session has been started,
  # returns the IP address from the socket:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.start
  #   http.ipaddr # => "172.67.155.76"
  #   http.finish
  #
  # source://net-http//net/http.rb#995
  def ipaddr; end

  # Sets the IP address for the connection:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.ipaddr # => nil
  #   http.ipaddr = '172.67.155.76'
  #   http.ipaddr # => "172.67.155.76"
  #
  # The IP address may not be set if the session has been started.
  #
  # @raise [IOError]
  #
  # source://net-http//net/http.rb#1007
  def ipaddr=(addr); end

  # Seconds to reuse the connection of the previous request.
  # If the idle time is less than this Keep-Alive Timeout,
  # Net::HTTP reuses the TCP/IP socket used by the previous communication.
  # The default value is 2 seconds.
  #
  # source://net-http//net/http.rb#1094
  def keep_alive_timeout; end

  # Seconds to reuse the connection of the previous request.
  # If the idle time is less than this Keep-Alive Timeout,
  # Net::HTTP reuses the TCP/IP socket used by the previous communication.
  # The default value is 2 seconds.
  #
  # source://net-http//net/http.rb#1094
  def keep_alive_timeout=(_arg0); end

  # Sets an OpenSSL::PKey::RSA or OpenSSL::PKey::DSA object.
  # (This method is appeared in Michal Rokos's OpenSSL extension.)
  #
  # source://net-http//net/http.rb#1186
  def key; end

  # Sets an OpenSSL::PKey::RSA or OpenSSL::PKey::DSA object.
  # (This method is appeared in Michal Rokos's OpenSSL extension.)
  #
  # source://net-http//net/http.rb#1186
  def key=(_arg0); end

  # The local host used to establish the connection.
  #
  # source://net-http//net/http.rb#937
  def local_host; end

  # The local host used to establish the connection.
  #
  # source://net-http//net/http.rb#937
  def local_host=(_arg0); end

  # The local port used to establish the connection.
  #
  # source://net-http//net/http.rb#940
  def local_port; end

  # The local port used to establish the connection.
  #
  # source://net-http//net/http.rb#940
  def local_port=(_arg0); end

  # Sends a LOCK request to the +path+ and gets a response,
  # as an HTTPResponse object.
  #
  # source://net-http//net/http.rb#1649
  def lock(path, body, initheader = T.unsafe(nil)); end

  # Returns the value of attribute max_retries.
  #
  # source://net-http//net/http.rb#1051
  def max_retries; end

  # Sets the maximum number of times to retry an idempotent request in case of
  # Net::ReadTimeout, IOError, EOFError, Errno::ECONNRESET,
  # Errno::ECONNABORTED, Errno::EPIPE, OpenSSL::SSL::SSLError,
  # Timeout::Error.
  # The initial value is 1.
  #
  # Argument +retries+ must be a non-negative numeric value:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.max_retries = 2   # => 2
  #   http.max_retries       # => 2
  #
  # source://net-http//net/http.rb#1043
  def max_retries=(retries); end

  # Sets the maximum SSL version.  See OpenSSL::SSL::SSLContext#max_version=
  #
  # source://net-http//net/http.rb#1198
  def max_version; end

  # Sets the maximum SSL version.  See OpenSSL::SSL::SSLContext#max_version=
  #
  # source://net-http//net/http.rb#1198
  def max_version=(_arg0); end

  # Sets the minimum SSL version.  See OpenSSL::SSL::SSLContext#min_version=
  #
  # source://net-http//net/http.rb#1195
  def min_version; end

  # Sets the minimum SSL version.  See OpenSSL::SSL::SSLContext#min_version=
  #
  # source://net-http//net/http.rb#1195
  def min_version=(_arg0); end

  # Sends a MKCOL request to the +path+ and gets a response,
  # as an HTTPResponse object.
  #
  # source://net-http//net/http.rb#1691
  def mkcol(path, body = T.unsafe(nil), initheader = T.unsafe(nil)); end

  # Sends a MOVE request to the +path+ and gets a response,
  # as an HTTPResponse object.
  #
  # source://net-http//net/http.rb#1679
  def move(path, initheader = T.unsafe(nil)); end

  # Number of seconds to wait for the connection to open. Any number
  # may be used, including Floats for fractional seconds. If the HTTP
  # object cannot open a connection in this many seconds, it raises a
  # Net::OpenTimeout exception. The default value is 60 seconds.
  #
  # source://net-http//net/http.rb#1016
  def open_timeout; end

  # Number of seconds to wait for the connection to open. Any number
  # may be used, including Floats for fractional seconds. If the HTTP
  # object cannot open a connection in this many seconds, it raises a
  # Net::OpenTimeout exception. The default value is 60 seconds.
  #
  # source://net-http//net/http.rb#1016
  def open_timeout=(_arg0); end

  # Sends a OPTIONS request to the +path+ and gets a response,
  # as an HTTPResponse object.
  #
  # source://net-http//net/http.rb#1661
  def options(path, initheader = T.unsafe(nil)); end

  # Sends a PATCH request to the +path+ and gets a response,
  # as an HTTPResponse object.
  #
  # source://net-http//net/http.rb#1633
  def patch(path, data, initheader = T.unsafe(nil), dest = T.unsafe(nil), &block); end

  # Returns the X.509 certificates the server presented.
  #
  # source://net-http//net/http.rb#1217
  def peer_cert; end

  # The port number to connect to.
  #
  # source://net-http//net/http.rb#934
  def port; end

  # Posts +data+ (must be a String) to +path+. +header+ must be a Hash
  # like { 'Accept' => '*/*', ... }.
  #
  # This method returns a Net::HTTPResponse object.
  #
  # If called with a block, yields each fragment of the
  # entity body in turn as a string as it is read from
  # the socket.  Note that in this case, the returned response
  # object will *not* contain a (meaningful) body.
  #
  # +dest+ argument is obsolete.
  # It still works but you must not use it.
  #
  # This method never raises exception.
  #
  #     response = http.post('/cgi-bin/search.rb', 'query=foo')
  #
  #     # using block
  #     File.open('result.txt', 'w') {|f|
  #       http.post('/cgi-bin/search.rb', 'query=foo') do |str|
  #         f.write str
  #       end
  #     }
  #
  # You should set Content-Type: header field for POST.
  # If no Content-Type: field given, this method uses
  # "application/x-www-form-urlencoded" by default.
  #
  # source://net-http//net/http.rb#1627
  def post(path, data, initheader = T.unsafe(nil), dest = T.unsafe(nil), &block); end

  # Sends a POST request to the +path+.
  #
  # Returns the response as a Net::HTTPResponse object.
  #
  # When called with a block, the block is passed an HTTPResponse
  # object.  The body of that response will not have been read yet;
  # the block can process it using HTTPResponse#read_body, if desired.
  #
  # Returns the response.
  #
  # This method never raises Net::* exceptions.
  #
  #     # example
  #     response = http.request_post('/cgi-bin/nice.rb', 'datadatadata...')
  #     p response.status
  #     puts response.body          # body is already read in this case
  #
  #     # using block
  #     http.request_post('/cgi-bin/nice.rb', 'datadatadata...') {|response|
  #       p response.status
  #       p response['content-type']
  #       response.read_body do |str|   # read body now
  #         print str
  #       end
  #     }
  #
  # source://net-http//net/http.rb#1770
  def post2(path, data, initheader = T.unsafe(nil), &block); end

  # Sends a PROPFIND request to the +path+ and gets a response,
  # as an HTTPResponse object.
  #
  # source://net-http//net/http.rb#1667
  def propfind(path, body = T.unsafe(nil), initheader = T.unsafe(nil)); end

  # Sends a PROPPATCH request to the +path+ and gets a response,
  # as an HTTPResponse object.
  #
  # source://net-http//net/http.rb#1643
  def proppatch(path, body, initheader = T.unsafe(nil)); end

  # True if requests for this connection will be proxied
  #
  # @return [Boolean]
  #
  # source://net-http//net/http.rb#1442
  def proxy?; end

  # The address of the proxy server, if one is configured.
  #
  # source://net-http//net/http.rb#1461
  def proxy_address; end

  # Sets the attribute proxy_address
  #
  # @param value the value to set the attribute proxy_address to.
  #
  # source://net-http//net/http.rb#971
  def proxy_address=(_arg0); end

  # Sets the attribute proxy_from_env
  #
  # @param value the value to set the attribute proxy_from_env to.
  #
  # source://net-http//net/http.rb#970
  def proxy_from_env=(_arg0); end

  # True if the proxy for this connection is determined from the environment
  #
  # @return [Boolean]
  #
  # source://net-http//net/http.rb#1447
  def proxy_from_env?; end

  # The password of the proxy server, if one is configured.
  #
  # source://net-http//net/http.rb#1489
  def proxy_pass; end

  # Sets the attribute proxy_pass
  #
  # @param value the value to set the attribute proxy_pass to.
  #
  # source://net-http//net/http.rb#974
  def proxy_pass=(_arg0); end

  # The port of the proxy server, if one is configured.
  #
  # source://net-http//net/http.rb#1470
  def proxy_port; end

  # Sets the attribute proxy_port
  #
  # @param value the value to set the attribute proxy_port to.
  #
  # source://net-http//net/http.rb#972
  def proxy_port=(_arg0); end

  # The proxy URI determined from the environment for this connection.
  #
  # source://net-http//net/http.rb#1452
  def proxy_uri; end

  # The username of the proxy server, if one is configured.
  #
  # source://net-http//net/http.rb#1479
  def proxy_user; end

  # Sets the attribute proxy_user
  #
  # @param value the value to set the attribute proxy_user to.
  #
  # source://net-http//net/http.rb#973
  def proxy_user=(_arg0); end

  # The address of the proxy server, if one is configured.
  #
  # source://net-http//net/http.rb#1461
  def proxyaddr; end

  # The port of the proxy server, if one is configured.
  #
  # source://net-http//net/http.rb#1470
  def proxyport; end

  # source://net-http//net/http.rb#1637
  def put(path, data, initheader = T.unsafe(nil)); end

  # source://net-http//net/http.rb#1774
  def put2(path, data, initheader = T.unsafe(nil), &block); end

  # Number of seconds to wait for one block to be read (via one read(2)
  # call). Any number may be used, including Floats for fractional
  # seconds. If the HTTP object cannot read data in this many seconds,
  # it raises a Net::ReadTimeout exception. The default value is 60 seconds.
  #
  # source://net-http//net/http.rb#1022
  def read_timeout; end

  # Sets the read timeout, in seconds, for +self+ to integer +sec+;
  # the initial value is 60.
  #
  # Argument +sec+ must be a non-negative numeric value:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.read_timeout # => 60
  #   http.get('/todos/1') # => #<Net::HTTPOK 200 OK readbody=true>
  #   http.read_timeout = 0
  #   http.get('/todos/1') # Raises Net::ReadTimeout.
  #
  # source://net-http//net/http.rb#1064
  def read_timeout=(sec); end

  # Sends an HTTPRequest object +req+ to the HTTP server.
  #
  # If +req+ is a Net::HTTP::Post or Net::HTTP::Put request containing
  # data, the data is also sent. Providing data for a Net::HTTP::Head or
  # Net::HTTP::Get request results in an ArgumentError.
  #
  # Returns an HTTPResponse object.
  #
  # When called with a block, passes an HTTPResponse object to the block.
  # The body of the response will not have been read yet;
  # the block can process it using HTTPResponse#read_body,
  # if desired.
  #
  # This method never raises Net::* exceptions.
  #
  # source://net-http//net/http.rb#1815
  def request(req, body = T.unsafe(nil), &block); end

  # Sends a GET request to the +path+.
  # Returns the response as a Net::HTTPResponse object.
  #
  # When called with a block, passes an HTTPResponse object to the block.
  # The body of the response will not have been read yet;
  # the block can process it using HTTPResponse#read_body,
  # if desired.
  #
  # Returns the response.
  #
  # This method never raises Net::* exceptions.
  #
  #     response = http.request_get('/index.html')
  #     # The entity body is already read in this case.
  #     p response['content-type']
  #     puts response.body
  #
  #     # Using a block
  #     http.request_get('/index.html') {|response|
  #       p response['content-type']
  #       response.read_body do |str|   # read body now
  #         print str
  #       end
  #     }
  #
  # source://net-http//net/http.rb#1726
  def request_get(path, initheader = T.unsafe(nil), &block); end

  # Sends a HEAD request to the +path+ and returns the response
  # as a Net::HTTPResponse object.
  #
  # Returns the response.
  #
  # This method never raises Net::* exceptions.
  #
  #     response = http.request_head('/index.html')
  #     p response['content-type']
  #
  # source://net-http//net/http.rb#1740
  def request_head(path, initheader = T.unsafe(nil), &block); end

  # Sends a POST request to the +path+.
  #
  # Returns the response as a Net::HTTPResponse object.
  #
  # When called with a block, the block is passed an HTTPResponse
  # object.  The body of that response will not have been read yet;
  # the block can process it using HTTPResponse#read_body, if desired.
  #
  # Returns the response.
  #
  # This method never raises Net::* exceptions.
  #
  #     # example
  #     response = http.request_post('/cgi-bin/nice.rb', 'datadatadata...')
  #     p response.status
  #     puts response.body          # body is already read in this case
  #
  #     # using block
  #     http.request_post('/cgi-bin/nice.rb', 'datadatadata...') {|response|
  #       p response.status
  #       p response['content-type']
  #       response.read_body do |str|   # read body now
  #         print str
  #       end
  #     }
  #
  # source://net-http//net/http.rb#1770
  def request_post(path, data, initheader = T.unsafe(nil), &block); end

  # source://net-http//net/http.rb#1774
  def request_put(path, data, initheader = T.unsafe(nil), &block); end

  # The encoding to use for the response body.  If Encoding, uses the
  # specified encoding.  If other true value, tries to detect the response
  # body encoding.
  #
  # source://net-http//net/http.rb#945
  def response_body_encoding; end

  # Sets the encoding to be used for the response body;
  # returns the encoding.
  #
  # The given +value+ may be:
  #
  # - An Encoding object.
  # - The name of an encoding.
  # - An alias for an encoding name.
  #
  # See {Encoding}[rdoc-ref:Encoding].
  #
  # Examples:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.response_body_encoding = Encoding::US_ASCII # => #<Encoding:US-ASCII>
  #   http.response_body_encoding = 'US-ASCII'         # => "US-ASCII"
  #   http.response_body_encoding = 'ASCII'            # => "ASCII"
  #
  # source://net-http//net/http.rb#965
  def response_body_encoding=(value); end

  # Sends an HTTP request to the HTTP server.
  # Also sends a DATA string if +data+ is given.
  #
  # Returns a Net::HTTPResponse object.
  #
  # This method never raises Net::* exceptions.
  #
  #    response = http.send_request('GET', '/index.html')
  #    puts response.body
  #
  # source://net-http//net/http.rb#1794
  def send_request(name, path, data = T.unsafe(nil), header = T.unsafe(nil)); end

  # *WARNING* This method opens a serious security hole.
  # Never use this method in production code.
  #
  # Sets the output stream for debugging:
  #
  #   http = Net::HTTP.new(hostname)
  #   File.open('t.tmp', 'w') do |file|
  #     http.set_debug_output(file)
  #     http.start
  #     http.get('/nosuch/1')
  #     http.finish
  #   end
  #   puts File.read('t.tmp')
  #
  # Output:
  #
  #   opening connection to jsonplaceholder.typicode.com:80...
  #   opened
  #   <- "GET /nosuch/1 HTTP/1.1\r\nAccept-Encoding: gzip;q=1.0,deflate;q=0.6,identity;q=0.3\r\nAccept: */*\r\nUser-Agent: Ruby\r\nHost: jsonplaceholder.typicode.com\r\n\r\n"
  #   -> "HTTP/1.1 404 Not Found\r\n"
  #   -> "Date: Mon, 12 Dec 2022 21:14:11 GMT\r\n"
  #   -> "Content-Type: application/json; charset=utf-8\r\n"
  #   -> "Content-Length: 2\r\n"
  #   -> "Connection: keep-alive\r\n"
  #   -> "X-Powered-By: Express\r\n"
  #   -> "X-Ratelimit-Limit: 1000\r\n"
  #   -> "X-Ratelimit-Remaining: 999\r\n"
  #   -> "X-Ratelimit-Reset: 1670879660\r\n"
  #   -> "Vary: Origin, Accept-Encoding\r\n"
  #   -> "Access-Control-Allow-Credentials: true\r\n"
  #   -> "Cache-Control: max-age=43200\r\n"
  #   -> "Pragma: no-cache\r\n"
  #   -> "Expires: -1\r\n"
  #   -> "X-Content-Type-Options: nosniff\r\n"
  #   -> "Etag: W/\"2-vyGp6PvFo4RvsFtPoIWeCReyIC8\"\r\n"
  #   -> "Via: 1.1 vegur\r\n"
  #   -> "CF-Cache-Status: MISS\r\n"
  #   -> "Server-Timing: cf-q-config;dur=1.3000000762986e-05\r\n"
  #   -> "Report-To: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=yOr40jo%2BwS1KHzhTlVpl54beJ5Wx2FcG4gGV0XVrh3X9OlR5q4drUn2dkt5DGO4GDcE%2BVXT7CNgJvGs%2BZleIyMu8CLieFiDIvOviOY3EhHg94m0ZNZgrEdpKD0S85S507l1vsEwEHkoTm%2Ff19SiO\"}],\"group\":\"cf-nel\",\"max_age\":604800}\r\n"
  #   -> "NEL: {\"success_fraction\":0,\"report_to\":\"cf-nel\",\"max_age\":604800}\r\n"
  #   -> "Server: cloudflare\r\n"
  #   -> "CF-RAY: 778977dc484ce591-DFW\r\n"
  #   -> "alt-svc: h3=\":443\"; ma=86400, h3-29=\":443\"; ma=86400\r\n"
  #   -> "\r\n"
  #   reading 2 bytes...
  #   -> "{}"
  #   read 2 bytes
  #   Conn keep-alive
  #
  # source://net-http//net/http.rb#925
  def set_debug_output(output); end

  # Sets the SSL timeout seconds.
  #
  # source://net-http//net/http.rb#1189
  def ssl_timeout; end

  # Sets the SSL timeout seconds.
  #
  # source://net-http//net/http.rb#1189
  def ssl_timeout=(_arg0); end

  # Sets the SSL version.  See OpenSSL::SSL::SSLContext#ssl_version=
  #
  # source://net-http//net/http.rb#1192
  def ssl_version; end

  # Sets the SSL version.  See OpenSSL::SSL::SSLContext#ssl_version=
  #
  # source://net-http//net/http.rb#1192
  def ssl_version=(_arg0); end

  # Opens a TCP connection and HTTP session.
  #
  # When this method is called with a block, it passes the Net::HTTP
  # object to the block, and closes the TCP connection and HTTP session
  # after the block has been executed.
  #
  # When called with a block, it returns the return value of the
  # block; otherwise, it returns self.
  #
  # @raise [IOError]
  #
  # source://net-http//net/http.rb#1233
  def start; end

  # Returns true if the HTTP session has been started.
  #
  # @return [Boolean]
  #
  # source://net-http//net/http.rb#1101
  def started?; end

  # Sends a TRACE request to the +path+ and gets a response,
  # as an HTTPResponse object.
  #
  # source://net-http//net/http.rb#1697
  def trace(path, initheader = T.unsafe(nil)); end

  # Sends a UNLOCK request to the +path+ and gets a response,
  # as an HTTPResponse object.
  #
  # source://net-http//net/http.rb#1655
  def unlock(path, body, initheader = T.unsafe(nil)); end

  # Turn on/off SSL.
  # This flag must be set before starting session.
  # If you change use_ssl value after session started,
  # a Net::HTTP object raises IOError.
  #
  # source://net-http//net/http.rb#1118
  def use_ssl=(flag); end

  # Returns true if SSL/TLS is being used with HTTP.
  #
  # @return [Boolean]
  #
  # source://net-http//net/http.rb#1110
  def use_ssl?; end

  # Sets the verify callback for the server certification verification.
  #
  # source://net-http//net/http.rb#1201
  def verify_callback; end

  # Sets the verify callback for the server certification verification.
  #
  # source://net-http//net/http.rb#1201
  def verify_callback=(_arg0); end

  # Sets the maximum depth for the certificate chain verification.
  #
  # source://net-http//net/http.rb#1204
  def verify_depth; end

  # Sets the maximum depth for the certificate chain verification.
  #
  # source://net-http//net/http.rb#1204
  def verify_depth=(_arg0); end

  # Sets to check the server certificate is valid for the hostname.
  # See OpenSSL::SSL::SSLContext#verify_hostname=
  #
  # source://net-http//net/http.rb#1214
  def verify_hostname; end

  # Sets to check the server certificate is valid for the hostname.
  # See OpenSSL::SSL::SSLContext#verify_hostname=
  #
  # source://net-http//net/http.rb#1214
  def verify_hostname=(_arg0); end

  # Sets the flags for server the certification verification at beginning of
  # SSL/TLS session.
  #
  # OpenSSL::SSL::VERIFY_NONE or OpenSSL::SSL::VERIFY_PEER are acceptable.
  #
  # source://net-http//net/http.rb#1210
  def verify_mode; end

  # Sets the flags for server the certification verification at beginning of
  # SSL/TLS session.
  #
  # OpenSSL::SSL::VERIFY_NONE or OpenSSL::SSL::VERIFY_PEER are acceptable.
  #
  # source://net-http//net/http.rb#1210
  def verify_mode=(_arg0); end

  # Number of seconds to wait for one block to be written (via one write(2)
  # call). Any number may be used, including Floats for fractional
  # seconds. If the HTTP object cannot write data in this many seconds,
  # it raises a Net::WriteTimeout exception. The default value is 60 seconds.
  # Net::WriteTimeout is not raised on Windows.
  #
  # source://net-http//net/http.rb#1029
  def write_timeout; end

  # Sets the write timeout, in seconds, for +self+ to integer +sec+;
  # the initial value is 60.
  #
  # Argument +sec+ must be a non-negative numeric value.
  #
  # source://net-http//net/http.rb#1074
  def write_timeout=(sec); end

  private

  # Adds a message to debugging output
  #
  # source://net-http//net/http.rb#1992
  def D(msg); end

  # source://net-http//net/http.rb#1984
  def addr_port; end

  # source://net-http//net/http.rb#1901
  def begin_transport(req); end

  # without proxy, obsolete
  #
  # source://net-http//net/http.rb#1510
  def conn_address; end

  # source://net-http//net/http.rb#1514
  def conn_port; end

  # source://net-http//net/http.rb#1253
  def connect; end

  # Adds a message to debugging output
  #
  # source://net-http//net/http.rb#1992
  def debug(msg); end

  # source://net-http//net/http.rb#1374
  def do_finish; end

  # source://net-http//net/http.rb#1247
  def do_start; end

  # source://net-http//net/http.rb#1518
  def edit_path(path); end

  # source://net-http//net/http.rb#1924
  def end_transport(req, res); end

  # @return [Boolean]
  #
  # source://net-http//net/http.rb#1941
  def keep_alive?(req, res); end

  # source://net-http//net/http.rb#1363
  def on_connect; end

  # Executes a request which uses a representation
  # and returns its body.
  #
  # source://net-http//net/http.rb#1838
  def send_entity(path, data, initheader, dest, type, &block); end

  # source://net-http//net/http.rb#1965
  def sspi_auth(req); end

  # @return [Boolean]
  #
  # source://net-http//net/http.rb#1950
  def sspi_auth?(res); end

  # source://net-http//net/http.rb#1849
  def transport_request(req); end

  # source://net-http//net/http.rb#1503
  def unescape(value); end

  class << self
    # Creates an HTTP proxy class which behaves like Net::HTTP, but
    # performs all access via the specified proxy.
    #
    # This class is obsolete.  You may pass these same parameters directly to
    # Net::HTTP.new.  See Net::HTTP.new for details of the arguments.
    #
    # source://net-http//net/http.rb#1400
    def Proxy(p_addr = T.unsafe(nil), p_port = T.unsafe(nil), p_user = T.unsafe(nil), p_pass = T.unsafe(nil)); end

    # Returns intger +80+, the default port to use for HTTP requests:
    #
    #   Net::HTTP.default_port # => 80
    #
    # source://net-http//net/http.rb#558
    def default_port; end

    # :call-seq:
    #   Net::HTTP.get(hostname, path, port = 80) -> body
    #   Net::HTTP:get(uri, headers = {}, port = uri.port) -> body
    #
    # Sends a GET request and returns the \HTTP response body as a string.
    #
    # With string arguments +hostname+ and +path+:
    #
    #   hostname = 'jsonplaceholder.typicode.com'
    #   path = '/todos/1'
    #   puts Net::HTTP.get(hostname, path)
    #
    # Output:
    #
    #   {
    #     "userId": 1,
    #     "id": 1,
    #     "title": "delectus aut autem",
    #     "completed": false
    #   }
    #
    # With URI object +uri+ and optional hash argument +headers+:
    #
    #   uri = URI('https://jsonplaceholder.typicode.com/todos/1')
    #   headers = {'Content-type' => 'application/json; charset=UTF-8'}
    #   Net::HTTP.get(uri, headers)
    #
    # Related:
    #
    # - Net::HTTP::Get: request class for \HTTP method +GET+.
    # - Net::HTTP#get: convenience method for \HTTP method +GET+.
    #
    # source://net-http//net/http.rb#460
    def get(uri_or_host, path_or_headers = T.unsafe(nil), port = T.unsafe(nil)); end

    # :call-seq:
    #   Net::HTTP.get_print(hostname, path, port = 80) -> nil
    #   Net::HTTP:get_print(uri, headers = {}, port = uri.port) -> nil
    #
    # Like Net::HTTP.get, but writes the returned body to $stdout;
    # returns +nil+.
    #
    # source://net-http//net/http.rb#419
    def get_print(uri_or_host, path_or_headers = T.unsafe(nil), port = T.unsafe(nil)); end

    # :call-seq:
    #   Net::HTTP.get_response(hostname, path, port = 80) -> http_response
    #   Net::HTTP:get_response(uri, headers = {}, port = uri.port) -> http_response
    #
    # Like Net::HTTP.get, but returns a Net::HTTPResponse object
    # instead of the body string.
    #
    # source://net-http//net/http.rb#470
    def get_response(uri_or_host, path_or_headers = T.unsafe(nil), port = T.unsafe(nil), &block); end

    # Returns integer +80+, the default port to use for HTTP requests:
    #
    #   Net::HTTP.http_default_port # => 80
    #
    # source://net-http//net/http.rb#566
    def http_default_port; end

    # Returns integer +443+, the default port to use for HTTPS requests:
    #
    #   Net::HTTP.https_default_port # => 443
    #
    # source://net-http//net/http.rb#574
    def https_default_port; end

    # Returns +false+; retained for compatibility.
    #
    # @return [Boolean]
    #
    # source://net-http//net/http.rb#404
    def is_version_1_1?; end

    # Returns +true+; retained for compatibility.
    #
    # @return [Boolean]
    #
    # source://net-http//net/http.rb#399
    def is_version_1_2?; end

    # Returns a new Net::HTTP object +http+
    # (but does not open a TCP connection or HTTP session).
    #
    # <b>No Proxy</b>
    #
    # With only string argument +hostname+ given
    # (and <tt>ENV['http_proxy']</tt> undefined or +nil+),
    # the returned +http+:
    #
    # - Has the given address.
    # - Has the default port number, Net::HTTP.default_port (80).
    # - Has no proxy.
    #
    # Example:
    #
    #   http = Net::HTTP.new(hostname)
    #   # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
    #   http.address # => "jsonplaceholder.typicode.com"
    #   http.port    # => 80
    #   http.proxy?  # => false
    #
    # With integer argument +port+ also given,
    # the returned +http+ has the given port:
    #
    #   http = Net::HTTP.new(hostname, 8000)
    #   # => #<Net::HTTP jsonplaceholder.typicode.com:8000 open=false>
    #   http.port # => 8000
    #
    # <b>Proxy Using Argument +p_addr+ as a \String</b>
    #
    # When argument +p_addr+ is a string hostname,
    # the returned +http+ has a proxy:
    #
    #   http = Net::HTTP.new(hostname, nil, 'proxy.example')
    #   # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
    #   http.proxy?        # => true
    #   http.proxy_address # => "proxy.example"
    #   # These use default values.
    #   http.proxy_port    # => 80
    #   http.proxy_user    # => nil
    #   http.proxy_pass    # => nil
    #
    # The port, username, and password for the proxy may also be given:
    #
    #   http = Net::HTTP.new(hostname, nil, 'proxy.example', 8000, 'pname', 'ppass')
    #   # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
    #   http.proxy?        # => true
    #   http.proxy_address # => "proxy.example"
    #   http.proxy_port    # => 8000
    #   http.proxy_user    # => "pname"
    #   http.proxy_pass    # => "ppass"
    #
    # <b>Proxy Using <tt>ENV['http_proxy']</tt></b>
    #
    # When environment variable <tt>'http_proxy'</tt>
    # is set to a \URI string,
    # the returned +http+ will have that URI as its proxy;
    # note that the \URI string must have a protocol
    # such as <tt>'http'</tt> or <tt>'https'</tt>:
    #
    #   ENV['http_proxy'] = 'http://example.com'
    #   # => "http://example.com"
    #   http = Net::HTTP.new(hostname)
    #   # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
    #   http.proxy?        # => true
    #   http.address       # => "jsonplaceholder.typicode.com"
    #   http.proxy_address # => "example.com"
    #
    # The \URI string may include proxy username, password, and port number:
    #
    #   ENV['http_proxy'] = 'http://pname:ppass@example.com:8000'
    #   # => "http://pname:ppass@example.com:8000"
    #   http = Net::HTTP.new(hostname)
    #   # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
    #   http.proxy_port # => 8000
    #   http.proxy_user # => "pname"
    #   http.proxy_pass # => "ppass"
    #
    # <b>Argument +p_no_proxy+</b>
    #
    # You can use argument +p_no_proxy+ to reject certain proxies:
    #
    # - Reject a certain address:
    #
    #     http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example')
    #     http.proxy_address # => nil
    #
    # - Reject certain domains or subdomains:
    #
    #     http = Net::HTTP.new('example.com', nil, 'my.proxy.example', 8000, 'pname', 'ppass', 'proxy.example')
    #     http.proxy_address # => nil
    #
    # - Reject certain addresses and port combinations:
    #
    #     http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example:1234')
    #     http.proxy_address # => "proxy.example"
    #
    #     http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example:8000')
    #     http.proxy_address # => nil
    #
    # - Reject a list of the types above delimited using a comma:
    #
    #     http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'my.proxy,proxy.example:8000')
    #     http.proxy_address # => nil
    #
    #     http = Net::HTTP.new('example.com', nil, 'my.proxy', 8000, 'pname', 'ppass', 'my.proxy,proxy.example:8000')
    #     http.proxy_address # => nil
    #
    # source://net-http//net/http.rb#802
    def new(address, port = T.unsafe(nil), p_addr = T.unsafe(nil), p_port = T.unsafe(nil), p_user = T.unsafe(nil), p_pass = T.unsafe(nil), p_no_proxy = T.unsafe(nil)); end

    # Posts data to a host; returns a Net::HTTPResponse object.
    #
    # Argument +url+ must be a URL;
    # argument +data+ must be a string:
    #
    #   _uri = uri.dup
    #   _uri.path = '/posts'
    #   data = '{"title": "foo", "body": "bar", "userId": 1}'
    #   headers = {'content-type': 'application/json'}
    #   res = Net::HTTP.post(_uri, data, headers) # => #<Net::HTTPCreated 201 Created readbody=true>
    #   puts res.body
    #
    # Output:
    #
    #   {
    #     "title": "foo",
    #     "body": "bar",
    #     "userId": 1,
    #     "id": 101
    #   }
    #
    # Related:
    #
    # - Net::HTTP::Post: request class for \HTTP method +POST+.
    # - Net::HTTP#post: convenience method for \HTTP method +POST+.
    #
    # source://net-http//net/http.rb#513
    def post(url, data, header = T.unsafe(nil)); end

    # Posts data to a host; returns a Net::HTTPResponse object.
    #
    # Argument +url+ must be a URI;
    # argument +data+ must be a hash:
    #
    #   _uri = uri.dup
    #   _uri.path = '/posts'
    #   data = {title: 'foo', body: 'bar', userId: 1}
    #   res = Net::HTTP.post_form(_uri, data) # => #<Net::HTTPCreated 201 Created readbody=true>
    #   puts res.body
    #
    # Output:
    #
    #   {
    #     "title": "foo",
    #     "body": "bar",
    #     "userId": "1",
    #     "id": 101
    #   }
    #
    # source://net-http//net/http.rb#540
    def post_form(url, params); end

    # Address of proxy host. If Net::HTTP does not use a proxy, nil.
    #
    # source://net-http//net/http.rb#1428
    def proxy_address; end

    # returns true if self is a class which was created by HTTP::Proxy.
    #
    # @return [Boolean]
    #
    # source://net-http//net/http.rb#1423
    def proxy_class?; end

    # User password for accessing proxy. If Net::HTTP does not use a proxy,
    # nil.
    #
    # source://net-http//net/http.rb#1438
    def proxy_pass; end

    # Port number of proxy host. If Net::HTTP does not use a proxy, nil.
    #
    # source://net-http//net/http.rb#1431
    def proxy_port; end

    # User name for accessing proxy. If Net::HTTP does not use a proxy, nil.
    #
    # source://net-http//net/http.rb#1434
    def proxy_user; end

    # source://net-http//net/http.rb#578
    def socket_type; end

    # :call-seq:
    #   HTTP.start(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, opts) -> http
    #   HTTP.start(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, opts) {|http| ... } -> object
    #
    # Creates a new \Net::HTTP object, +http+, via \Net::HTTP.new:
    #
    #   Net::HTTP.new(address, port, p_addr, p_port, p_user, p_pass)
    #
    # - For arguments +hostname+ through +p_pass+, see Net::HTTP.new.
    # - For argument +opts+, see below.
    #
    # Note: If +port+ is +nil+ and <tt>opts[:use_ssl]</tt> is a truthy value,
    # the value passed to +new+ is Net::HTTP.https_default_port, not +port+.
    #
    # With no block given:
    #
    # - Calls <tt>http.start</tt> with no block (see #start),
    #   which opens a TCP connection and \HTTP session.
    # - Returns +http+.
    # - The caller should call #finish to close the session:
    #
    #     http = Net::HTTP.start(hostname)
    #     http.started? # => true
    #     http.finish
    #     http.started? # => false
    #
    # With a block given:
    #
    # - Calls <tt>http.start</tt> with the block (see #start), which:
    #
    #   - Opens a TCP connection and \HTTP session.
    #   - Calls the block,
    #     which may make any number of requests to the host.
    #   - Closes the \HTTP session and TCP connection on block exit.
    #   - Returns the block's value +object+.
    #
    # - Returns +object+.
    #
    # Example:
    #
    #   hostname = 'jsonplaceholder.typicode.com'
    #   Net::HTTP.start(hostname) do |http|
    #     puts http.get('/todos/1').body
    #     puts http.get('/todos/2').body
    #   end
    #
    # Output:
    #
    #   {
    #     "userId": 1,
    #     "id": 1,
    #     "title": "delectus aut autem",
    #     "completed": false
    #   }
    #   {
    #     "userId": 1,
    #     "id": 2,
    #     "title": "quis ut nam facilis et officia qui",
    #     "completed": false
    #   }
    #
    # If the last argument given is a hash, it is the +opts+ hash,
    # where each key is a method or accessor to be called,
    # and its value is the value to be set.
    #
    # The keys may include:
    #
    # - #ca_file
    # - #ca_path
    # - #cert
    # - #cert_store
    # - #ciphers
    # - #close_on_empty_response
    # - +ipaddr+ (calls #ipaddr=)
    # - #keep_alive_timeout
    # - #key
    # - #open_timeout
    # - #read_timeout
    # - #ssl_timeout
    # - #ssl_version
    # - +use_ssl+ (calls #use_ssl=)
    # - #verify_callback
    # - #verify_depth
    # - #verify_mode
    # - #write_timeout
    #
    # source://net-http//net/http.rb#668
    def start(address, *arg, &block); end

    # Returns +false+; retained for compatibility.
    #
    # @return [Boolean]
    #
    # source://net-http//net/http.rb#404
    def version_1_1?; end

    # Returns +true+; retained for compatibility.
    #
    # source://net-http//net/http.rb#394
    def version_1_2; end

    # Returns +true+; retained for compatibility.
    #
    # @return [Boolean]
    #
    # source://net-http//net/http.rb#399
    def version_1_2?; end
  end
end

module Net::HTTP::ProxyDelta
  private

  # source://net-http//net/http/proxy_delta.rb#5
  def conn_address; end

  # source://net-http//net/http/proxy_delta.rb#9
  def conn_port; end

  # source://net-http//net/http/proxy_delta.rb#13
  def edit_path(path); end
end

# source://net-http//net/http/backward.rb#7
Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta

# :stopdoc:
#
# source://net-http//net/http.rb#382
Net::HTTP::VERSION = T.let(T.unsafe(nil), String)

# Response class for <tt>Already Reported (WebDAV)</tt> responses (status code 208).
#
# The <tt>Already Reported (WebDAV)</tt> response indicates that the server
# has received the request,
# and that the members of a DAV binding have already been enumerated
# in a preceding part of the (multi-status) response,
# and are not being included again.
# See {208 Already Reported (WebDAV)}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#208].
class Net::HTTPAlreadyReported < ::Net::HTTPSuccess; end

# source://net-http//net/http/responses.rb#227
Net::HTTPAlreadyReported::HAS_BODY = T.let(T.unsafe(nil), TrueClass)

# source://net-http//net/http/responses.rb#67
Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPClientException

# source://net-http//net/http/backward.rb#23
Net::HTTPClientErrorCode = Net::HTTPClientError

# Response class for <tt>Early Hints</tt> responses (status code 103).
#
# The <tt>Early Hints</tt> indicates that the server has received
# and is processing the request, and contains certain headers;
# the final response is not available yet.
#
# References:
#
# - {Mozilla}[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#103].
class Net::HTTPEarlyHints < ::Net::HTTPInformation; end

# source://net-http//net/http/responses.rb#138
Net::HTTPEarlyHints::HAS_BODY = T.let(T.unsafe(nil), FalseClass)

# source://net-http//net/http/backward.rb#24
Net::HTTPFatalErrorCode = Net::HTTPClientError

# HTTPGenericRequest is the parent of the Net::HTTPRequest class.
# Do not use this directly; use a subclass of Net::HTTPRequest.
#
# Mixes in the Net::HTTPHeader module to provide easier access to HTTP headers.
class Net::HTTPGenericRequest
  include ::Net::HTTPHeader

  # @return [HTTPGenericRequest] a new instance of HTTPGenericRequest
  #
  # source://net-http//net/http/generic_request.rb#11
  def initialize(m, reqbody, resbody, uri_or_path, initheader = T.unsafe(nil)); end

  # Don't automatically decode response content-encoding if the user indicates
  # they want to handle it.
  #
  # source://net-http//net/http/generic_request.rb#73
  def []=(key, val); end

  # Returns the value of attribute body.
  #
  # source://net-http//net/http/generic_request.rb#92
  def body; end

  # source://net-http//net/http/generic_request.rb#94
  def body=(str); end

  # @return [Boolean]
  #
  # source://net-http//net/http/generic_request.rb#87
  def body_exist?; end

  # Returns the value of attribute body_stream.
  #
  # source://net-http//net/http/generic_request.rb#101
  def body_stream; end

  # source://net-http//net/http/generic_request.rb#103
  def body_stream=(input); end

  # Automatically set to false if the user sets the Accept-Encoding header.
  # This indicates they wish to handle Content-encoding in responses
  # themselves.
  #
  # source://net-http//net/http/generic_request.rb#63
  def decode_content; end

  # write
  #
  # source://net-http//net/http/generic_request.rb#122
  def exec(sock, ver, path); end

  # source://net-http//net/http/generic_request.rb#65
  def inspect; end

  # Returns the value of attribute method.
  #
  # source://net-http//net/http/generic_request.rb#56
  def method; end

  # Returns the value of attribute path.
  #
  # source://net-http//net/http/generic_request.rb#57
  def path; end

  # @return [Boolean]
  #
  # source://net-http//net/http/generic_request.rb#79
  def request_body_permitted?; end

  # @return [Boolean]
  #
  # source://net-http//net/http/generic_request.rb#83
  def response_body_permitted?; end

  # @raise [ArgumentError]
  #
  # source://net-http//net/http/generic_request.rb#110
  def set_body_internal(str); end

  # source://net-http//net/http/generic_request.rb#134
  def update_uri(addr, port, ssl); end

  # Returns the value of attribute uri.
  #
  # source://net-http//net/http/generic_request.rb#58
  def uri; end

  private

  # source://net-http//net/http/generic_request.rb#236
  def encode_multipart_form_data(out, params, opt); end

  # source://net-http//net/http/generic_request.rb#292
  def flush_buffer(out, buf, chunked_p); end

  # source://net-http//net/http/generic_request.rb#287
  def quote_string(str, charset); end

  # source://net-http//net/http/generic_request.rb#184
  def send_request_with_body(sock, ver, path, body); end

  # source://net-http//net/http/generic_request.rb#210
  def send_request_with_body_data(sock, ver, path, params); end

  # source://net-http//net/http/generic_request.rb#193
  def send_request_with_body_stream(sock, ver, path, f); end

  # source://net-http//net/http/generic_request.rb#300
  def supply_default_content_type; end

  # Waits up to the continue timeout for a response from the server provided
  # we're speaking HTTP 1.1 and are expecting a 100-continue response.
  #
  # source://net-http//net/http/generic_request.rb#310
  def wait_for_continue(sock, ver); end

  # source://net-http//net/http/generic_request.rb#323
  def write_header(sock, ver, path); end
end

class Net::HTTPGenericRequest::Chunker
  # @return [Chunker] a new instance of Chunker
  #
  # source://net-http//net/http/generic_request.rb#167
  def initialize(sock); end

  # source://net-http//net/http/generic_request.rb#179
  def finish; end

  # source://net-http//net/http/generic_request.rb#172
  def write(buf); end
end

# The \HTTPHeader module provides access to \HTTP headers.
#
# The module is included in:
#
# - Net::HTTPGenericRequest (and therefore Net::HTTPRequest).
# - Net::HTTPResponse.
#
# The headers are a hash-like collection of key/value pairs called _fields_.
#
# == Request and Response Fields
#
# Headers may be included in:
#
# - A Net::HTTPRequest object:
#   the object's headers will be sent with the request.
#   Any fields may be defined in the request;
#   see {Setters}[rdoc-ref:Net::HTTPHeader@Setters].
# - A Net::HTTPResponse object:
#   the objects headers are usually those returned from the host.
#   Fields may be retrieved from the object;
#   see {Getters}[rdoc-ref:Net::HTTPHeader@Getters]
#   and {Iterators}[rdoc-ref:Net::HTTPHeader@Iterators].
#
# Exactly which fields should be sent or expected depends on the host;
# see:
#
# - {Request fields}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Request_fields].
# - {Response fields}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Response_fields].
#
# == About the Examples
#
# :include: doc/net-http/examples.rdoc
#
# == Fields
#
# A header field is a key/value pair.
#
# === Field Keys
#
# A field key may be:
#
# - A string: Key <tt>'Accept'</tt> is treated as if it were
#   <tt>'Accept'.downcase</tt>;  i.e., <tt>'accept'</tt>.
# - A symbol: Key <tt>:Accept</tt> is treated as if it were
#   <tt>:Accept.to_s.downcase</tt>;  i.e., <tt>'accept'</tt>.
#
# Examples:
#
#   req = Net::HTTP::Get.new(uri)
#   req[:accept]  # => "*/*"
#   req['Accept'] # => "*/*"
#   req['ACCEPT'] # => "*/*"
#
#   req['accept'] = 'text/html'
#   req[:accept] = 'text/html'
#   req['ACCEPT'] = 'text/html'
#
# === Field Values
#
# A field value may be returned as an array of strings or as a string:
#
# - These methods return field values as arrays:
#
#   - #get_fields: Returns the array value for the given key,
#     or +nil+ if it does not exist.
#   - #to_hash: Returns a hash of all header fields:
#     each key is a field name; its value is the array value for the field.
#
# - These methods return field values as string;
#   the string value for a field is equivalent to
#   <tt>self[key.downcase.to_s].join(', '))</tt>:
#
#   - #[]: Returns the string value for the given key,
#     or +nil+ if it does not exist.
#   - #fetch: Like #[], but accepts a default value
#     to be returned if the key does not exist.
#
# The field value may be set:
#
# - #[]=: Sets the value for the given key;
#   the given value may be a string, a symbol, an array, or a hash.
# - #add_field: Adds a given value to a value for the given key
#   (not overwriting the existing value).
# - #delete: Deletes the field for the given key.
#
# Example field values:
#
# - \String:
#
#     req['Accept'] = 'text/html' # => "text/html"
#     req['Accept']               # => "text/html"
#     req.get_fields('Accept')    # => ["text/html"]
#
# - \Symbol:
#
#     req['Accept'] = :text    # => :text
#     req['Accept']            # => "text"
#     req.get_fields('Accept') # => ["text"]
#
# - Simple array:
#
#     req[:foo] = %w[bar baz bat]
#     req[:foo]            # => "bar, baz, bat"
#     req.get_fields(:foo) # => ["bar", "baz", "bat"]
#
# - Simple hash:
#
#     req[:foo] = {bar: 0, baz: 1, bat: 2}
#     req[:foo]            # => "bar, 0, baz, 1, bat, 2"
#     req.get_fields(:foo) # => ["bar", "0", "baz", "1", "bat", "2"]
#
# - Nested:
#
#     req[:foo] = [%w[bar baz], {bat: 0, bam: 1}]
#     req[:foo]            # => "bar, baz, bat, 0, bam, 1"
#     req.get_fields(:foo) # => ["bar", "baz", "bat", "0", "bam", "1"]
#
#     req[:foo] = {bar: %w[baz bat], bam: {bah: 0, bad: 1}}
#     req[:foo]            # => "bar, baz, bat, bam, bah, 0, bad, 1"
#     req.get_fields(:foo) # => ["bar", "baz", "bat", "bam", "bah", "0", "bad", "1"]
#
# == Convenience Methods
#
# Various convenience methods retrieve values, set values, query values,
# set form values, or iterate over fields.
#
# === Setters
#
# \Method #[]= can set any field, but does little to validate the new value;
# some of the other setter methods provide some validation:
#
# - #[]=: Sets the string or array value for the given key.
# - #add_field: Creates or adds to the array value for the given key.
# - #basic_auth: Sets the string authorization header for <tt>'Authorization'</tt>.
# - #content_length=: Sets the integer length for field <tt>'Content-Length</tt>.
# - #content_type=: Sets the string value for field <tt>'Content-Type'</tt>.
# - #proxy_basic_auth: Sets the string authorization header for <tt>'Proxy-Authorization'</tt>.
# - #set_range: Sets the value for field <tt>'Range'</tt>.
#
# === Form Setters
#
# - #set_form: Sets an HTML form data set.
# - #set_form_data: Sets header fields and a body from HTML form data.
#
# === Getters
#
# \Method #[] can retrieve the value of any field that exists,
# but always as a string;
# some of the other getter methods return something different
# from the simple string value:
#
# - #[]: Returns the string field value for the given key.
# - #content_length: Returns the integer value of field <tt>'Content-Length'</tt>.
# - #content_range: Returns the Range value of field <tt>'Content-Range'</tt>.
# - #content_type: Returns the string value of field <tt>'Content-Type'</tt>.
# - #fetch: Returns the string field value for the given key.
# - #get_fields: Returns the array field value for the given +key+.
# - #main_type: Returns first part of the string value of field <tt>'Content-Type'</tt>.
# - #sub_type: Returns second part of the string value of field <tt>'Content-Type'</tt>.
# - #range: Returns an array of Range objects of field <tt>'Range'</tt>, or +nil+.
# - #range_length: Returns the integer length of the range given in field <tt>'Content-Range'</tt>.
# - #type_params: Returns the string parameters for <tt>'Content-Type'</tt>.
#
# === Queries
#
# - #chunked?: Returns whether field <tt>'Transfer-Encoding'</tt> is set to <tt>'chunked'</tt>.
# - #connection_close?: Returns whether field <tt>'Connection'</tt> is set to <tt>'close'</tt>.
# - #connection_keep_alive?: Returns whether field <tt>'Connection'</tt> is set to <tt>'keep-alive'</tt>.
# - #key?: Returns whether a given key exists.
#
# === Iterators
#
# - #each_capitalized: Passes each field capitalized-name/value pair to the block.
# - #each_capitalized_name: Passes each capitalized field name to the block.
# - #each_header: Passes each field name/value pair to the block.
# - #each_name: Passes each field name to the block.
# - #each_value: Passes each string field value to the block.
module Net::HTTPHeader
  # Returns the string field value for the case-insensitive field +key+,
  # or +nil+ if there is no such key;
  # see {Fields}[rdoc-ref:Net::HTTPHeader@Fields]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res['Connection'] # => "keep-alive"
  #   res['Nosuch']     # => nil
  #
  # Note that some field values may be retrieved via convenience methods;
  # see {Getters}[rdoc-ref:Net::HTTPHeader@Getters].
  #
  # source://net-http//net/http/header.rb#216
  def [](key); end

  # Sets the value for the case-insensitive +key+ to +val+,
  # overwriting the previous value if the field exists;
  # see {Fields}[rdoc-ref:Net::HTTPHeader@Fields]:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req['Accept'] # => "*/*"
  #   req['Accept'] = 'text/html'
  #   req['Accept'] # => "text/html"
  #
  # Note that some field values may be set via convenience methods;
  # see {Setters}[rdoc-ref:Net::HTTPHeader@Setters].
  #
  # source://net-http//net/http/header.rb#232
  def []=(key, val); end

  # Adds value +val+ to the value array for field +key+ if the field exists;
  # creates the field with the given +key+ and +val+ if it does not exist.
  # see {Fields}[rdoc-ref:Net::HTTPHeader@Fields]:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req.add_field('Foo', 'bar')
  #   req['Foo']            # => "bar"
  #   req.add_field('Foo', 'baz')
  #   req['Foo']            # => "bar, baz"
  #   req.add_field('Foo', %w[baz bam])
  #   req['Foo']            # => "bar, baz, baz, bam"
  #   req.get_fields('Foo') # => ["bar", "baz", "baz", "bam"]
  #
  # source://net-http//net/http/header.rb#253
  def add_field(key, val); end

  # Set the Authorization: header for "Basic" authorization.
  #
  # source://net-http//net/http/header.rb#856
  def basic_auth(account, password); end

  # Like #each_header, but the keys are returned in capitalized form.
  #
  # Net::HTTPHeader#canonical_each is an alias for Net::HTTPHeader#each_capitalized.
  #
  # source://net-http//net/http/header.rb#476
  def canonical_each; end

  # Returns +true+ if field <tt>'Transfer-Encoding'</tt>
  # exists and has value <tt>'chunked'</tt>,
  # +false+ otherwise;
  # see {Transfer-Encoding response header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#transfer-encoding-response-header]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res['Transfer-Encoding'] # => "chunked"
  #   res.chunked?             # => true
  #
  # @return [Boolean]
  #
  # source://net-http//net/http/header.rb#646
  def chunked?; end

  # @return [Boolean]
  #
  # source://net-http//net/http/header.rb#870
  def connection_close?; end

  # @return [Boolean]
  #
  # source://net-http//net/http/header.rb#877
  def connection_keep_alive?; end

  # Returns the value of field <tt>'Content-Length'</tt> as an integer,
  # or +nil+ if there is no such field;
  # see {Content-Length request header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-length-request-header]:
  #
  #   res = Net::HTTP.get_response(hostname, '/nosuch/1')
  #   res.content_length # => 2
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res.content_length # => nil
  #
  # source://net-http//net/http/header.rb#608
  def content_length; end

  # Sets the value of field <tt>'Content-Length'</tt> to the given numeric;
  # see {Content-Length response header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-length-response-header]:
  #
  #   _uri = uri.dup
  #   hostname = _uri.hostname           # => "jsonplaceholder.typicode.com"
  #   _uri.path = '/posts'               # => "/posts"
  #   req = Net::HTTP::Post.new(_uri)    # => #<Net::HTTP::Post POST>
  #   req.body = '{"title": "foo","body": "bar","userId": 1}'
  #   req.content_length = req.body.size # => 42
  #   req.content_type = 'application/json'
  #   res = Net::HTTP.start(hostname) do |http|
  #     http.request(req)
  #   end # => #<Net::HTTPCreated 201 Created readbody=true>
  #
  # source://net-http//net/http/header.rb#629
  def content_length=(len); end

  # Returns a Range object representing the value of field
  # <tt>'Content-Range'</tt>, or +nil+ if no such field exists;
  # see {Content-Range response header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-range-response-header]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res['Content-Range'] # => nil
  #   res['Content-Range'] = 'bytes 0-499/1000'
  #   res['Content-Range'] # => "bytes 0-499/1000"
  #   res.content_range    # => 0..499
  #
  # source://net-http//net/http/header.rb#662
  def content_range; end

  # Returns the {media type}[https://en.wikipedia.org/wiki/Media_type]
  # from the value of field <tt>'Content-Type'</tt>,
  # or +nil+ if no such field exists;
  # see {Content-Type response header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-response-header]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res['content-type'] # => "application/json; charset=utf-8"
  #   res.content_type    # => "application/json"
  #
  # source://net-http//net/http/header.rb#693
  def content_type; end

  # Sets the value of field <tt>'Content-Type'</tt>;
  # returns the new value;
  # see {Content-Type request header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-request-header]:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req.set_content_type('application/json') # => ["application/json"]
  #
  # Net::HTTPHeader#content_type= is an alias for Net::HTTPHeader#set_content_type.
  #
  # source://net-http//net/http/header.rb#760
  def content_type=(type, params = T.unsafe(nil)); end

  # Removes the header for the given case-insensitive +key+
  # (see {Fields}[rdoc-ref:Net::HTTPHeader@Fields]);
  # returns the deleted value, or +nil+ if no such field exists:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req.delete('Accept') # => ["*/*"]
  #   req.delete('Nosuch') # => nil
  #
  # source://net-http//net/http/header.rb#445
  def delete(key); end

  # Calls the block with each key/value pair:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res.each_header do |key, value|
  #     p [key, value] if key.start_with?('c')
  #   end
  #
  # Output:
  #
  #   ["content-type", "application/json; charset=utf-8"]
  #   ["connection", "keep-alive"]
  #   ["cache-control", "max-age=43200"]
  #   ["cf-cache-status", "HIT"]
  #   ["cf-ray", "771d17e9bc542cf5-ORD"]
  #
  # Returns an enumerator if no block is given.
  #
  # Net::HTTPHeader#each is an alias for Net::HTTPHeader#each_header.
  #
  # source://net-http//net/http/header.rb#356
  def each; end

  # Like #each_header, but the keys are returned in capitalized form.
  #
  # Net::HTTPHeader#canonical_each is an alias for Net::HTTPHeader#each_capitalized.
  #
  # source://net-http//net/http/header.rb#476
  def each_capitalized; end

  # Calls the block with each capitalized field name:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res.each_capitalized_name do |key|
  #     p key if key.start_with?('C')
  #   end
  #
  # Output:
  #
  #   "Content-Type"
  #   "Connection"
  #   "Cache-Control"
  #   "Cf-Cache-Status"
  #   "Cf-Ray"
  #
  # The capitalization is system-dependent;
  # see {Case Mapping}[rdoc-ref:case_mapping.rdoc].
  #
  # Returns an enumerator if no block is given.
  #
  # source://net-http//net/http/header.rb#409
  def each_capitalized_name; end

  # Calls the block with each key/value pair:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res.each_header do |key, value|
  #     p [key, value] if key.start_with?('c')
  #   end
  #
  # Output:
  #
  #   ["content-type", "application/json; charset=utf-8"]
  #   ["connection", "keep-alive"]
  #   ["cache-control", "max-age=43200"]
  #   ["cf-cache-status", "HIT"]
  #   ["cf-ray", "771d17e9bc542cf5-ORD"]
  #
  # Returns an enumerator if no block is given.
  #
  # Net::HTTPHeader#each is an alias for Net::HTTPHeader#each_header.
  #
  # source://net-http//net/http/header.rb#356
  def each_header; end

  # Calls the block with each field key:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res.each_key do |key|
  #     p key if key.start_with?('c')
  #   end
  #
  # Output:
  #
  #   "content-type"
  #   "connection"
  #   "cache-control"
  #   "cf-cache-status"
  #   "cf-ray"
  #
  # Returns an enumerator if no block is given.
  #
  # Net::HTTPHeader#each_name is an alias for Net::HTTPHeader#each_key.
  #
  # source://net-http//net/http/header.rb#383
  def each_key(&block); end

  # Calls the block with each field key:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res.each_key do |key|
  #     p key if key.start_with?('c')
  #   end
  #
  # Output:
  #
  #   "content-type"
  #   "connection"
  #   "cache-control"
  #   "cf-cache-status"
  #   "cf-ray"
  #
  # Returns an enumerator if no block is given.
  #
  # Net::HTTPHeader#each_name is an alias for Net::HTTPHeader#each_key.
  #
  # source://net-http//net/http/header.rb#383
  def each_name(&block); end

  # Calls the block with each string field value:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res.each_value do |value|
  #     p value if value.start_with?('c')
  #   end
  #
  # Output:
  #
  #   "chunked"
  #   "cf-q-config;dur=6.0000002122251e-06"
  #   "cloudflare"
  #
  # Returns an enumerator if no block is given.
  #
  # source://net-http//net/http/header.rb#430
  def each_value; end

  # call-seq:
  #   fetch(key, default_val = nil) {|key| ... } -> object
  #   fetch(key, default_val = nil) -> value or default_val
  #
  # With a block, returns the string value for +key+ if it exists;
  # otherwise returns the value of the block;
  # ignores the +default_val+;
  # see {Fields}[rdoc-ref:Net::HTTPHeader@Fields]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #
  #   # Field exists; block not called.
  #   res.fetch('Connection') do |value|
  #     fail 'Cannot happen'
  #   end # => "keep-alive"
  #
  #   # Field does not exist; block called.
  #   res.fetch('Nosuch') do |value|
  #     value.downcase
  #   end # => "nosuch"
  #
  # With no block, returns the string value for +key+ if it exists;
  # otherwise, returns +default_val+ if it was given;
  # otherwise raises an exception:
  #
  #   res.fetch('Connection', 'Foo') # => "keep-alive"
  #   res.fetch('Nosuch', 'Foo')     # => "Foo"
  #   res.fetch('Nosuch')            # Raises KeyError.
  #
  # source://net-http//net/http/header.rb#333
  def fetch(key, *args, &block); end

  # Set header fields and a body from HTML form data.
  # +params+ should be an Array of Arrays or
  # a Hash containing HTML form data.
  # Optional argument +sep+ means data record separator.
  #
  # Values are URL encoded as necessary and the content-type is set to
  # application/x-www-form-urlencoded
  #
  # Example:
  #
  #    http.form_data = {"q" => "ruby", "lang" => "en"}
  #    http.form_data = {"q" => ["ruby", "perl"], "lang" => "en"}
  #    http.set_form_data({"q" => "ruby", "lang" => "en"}, ';')
  #
  # Net::HTTPHeader#form_data= is an alias for Net::HTTPHeader#set_form_data.
  #
  # source://net-http//net/http/header.rb#781
  def form_data=(params, sep = T.unsafe(nil)); end

  # Returns the array field value for the given +key+,
  # or +nil+ if there is no such field;
  # see {Fields}[rdoc-ref:Net::HTTPHeader@Fields]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res.get_fields('Connection') # => ["keep-alive"]
  #   res.get_fields('Nosuch')     # => nil
  #
  # source://net-http//net/http/header.rb#298
  def get_fields(key); end

  # source://net-http//net/http/header.rb#183
  def initialize_http_header(initheader); end

  # Returns +true+ if the field for the case-insensitive +key+ exists, +false+ otherwise:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req.key?('Accept') # => true
  #   req.key?('Nosuch') # => false
  #
  # @return [Boolean]
  #
  # source://net-http//net/http/header.rb#455
  def key?(key); end

  # source://net-http//net/http/header.rb#200
  def length; end

  # Returns the leading ('type') part of the
  # {media type}[https://en.wikipedia.org/wiki/Media_type]
  # from the value of field <tt>'Content-Type'</tt>,
  # or +nil+ if no such field exists;
  # see {Content-Type response header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-response-header]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res['content-type'] # => "application/json; charset=utf-8"
  #   res.main_type       # => "application"
  #
  # source://net-http//net/http/header.rb#711
  def main_type; end

  # Set Proxy-Authorization: header for "Basic" authorization.
  #
  # source://net-http//net/http/header.rb#861
  def proxy_basic_auth(account, password); end

  # Returns an array of Range objects that represent
  # the value of field <tt>'Range'</tt>,
  # or +nil+ if there is no such field;
  # see {Range request header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#range-request-header]:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req['Range'] = 'bytes=0-99,200-299,400-499'
  #   req.range # => [0..99, 200..299, 400..499]
  #   req.delete('Range')
  #   req.range # # => nil
  #
  # source://net-http//net/http/header.rb#501
  def range; end

  # call-seq:
  #   set_range(length) -> length
  #   set_range(offset, length) -> range
  #   set_range(begin..length) -> range
  #
  # Sets the value for field <tt>'Range'</tt>;
  # see {Range request header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#range-request-header]:
  #
  # With argument +length+:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req.set_range(100)      # => 100
  #   req['Range']            # => "bytes=0-99"
  #
  # With arguments +offset+ and +length+:
  #
  #   req.set_range(100, 100) # => 100...200
  #   req['Range']            # => "bytes=100-199"
  #
  # With argument +range+:
  #
  #   req.set_range(100..199) # => 100..199
  #   req['Range']            # => "bytes=100-199"
  #
  # Net::HTTPHeader#range= is an alias for Net::HTTPHeader#set_range.
  #
  # source://net-http//net/http/header.rb#568
  def range=(r, e = T.unsafe(nil)); end

  # Returns the integer representing length of the value of field
  # <tt>'Content-Range'</tt>, or +nil+ if no such field exists;
  # see {Content-Range response header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-range-response-header]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res['Content-Range'] # => nil
  #   res['Content-Range'] = 'bytes 0-499/1000'
  #   res.range_length     # => 500
  #
  # source://net-http//net/http/header.rb#679
  def range_length; end

  # Sets the value of field <tt>'Content-Type'</tt>;
  # returns the new value;
  # see {Content-Type request header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-request-header]:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req.set_content_type('application/json') # => ["application/json"]
  #
  # Net::HTTPHeader#content_type= is an alias for Net::HTTPHeader#set_content_type.
  #
  # source://net-http//net/http/header.rb#760
  def set_content_type(type, params = T.unsafe(nil)); end

  # Set an HTML form data set.
  # +params+ :: The form data to set, which should be an enumerable.
  #             See below for more details.
  # +enctype+ :: The content type to use to encode the form submission,
  #              which should be application/x-www-form-urlencoded or
  #              multipart/form-data.
  # +formopt+ :: An options hash, supporting the following options:
  #              :boundary :: The boundary of the multipart message. If
  #                           not given, a random boundary will be used.
  #              :charset :: The charset of the form submission. All
  #                          field names and values of non-file fields
  #                          should be encoded with this charset.
  #
  # Each item of params should respond to +each+ and yield 2-3 arguments,
  # or an array of 2-3 elements. The arguments yielded should be:
  #
  # - The name of the field.
  # - The value of the field, it should be a String or a File or IO-like.
  # - An options hash, supporting the following options
  #   (used only for file uploads); entries:
  #
  #   - +:filename+: The name of the file to use.
  #   - +:content_type+: The content type of the uploaded file.
  #
  # Each item is a file field or a normal field.
  # If +value+ is a File object or the +opt+ hash has a :filename key,
  # the item is treated as a file field.
  #
  # If Transfer-Encoding is set as chunked, this sends the request using
  # chunked encoding. Because chunked encoding is HTTP/1.1 feature,
  # you should confirm that the server supports HTTP/1.1 before using
  # chunked encoding.
  #
  # Example:
  #
  #    req.set_form([["q", "ruby"], ["lang", "en"]])
  #
  #    req.set_form({"f"=>File.open('/path/to/filename')},
  #                 "multipart/form-data",
  #                 charset: "UTF-8",
  #    )
  #
  #    req.set_form([["f",
  #                   File.open('/path/to/filename.bar'),
  #                   {filename: "other-filename.foo"}
  #                 ]],
  #                 "multipart/form-data",
  #    )
  #
  # See also RFC 2388, RFC 2616, HTML 4.01, and HTML5
  #
  # source://net-http//net/http/header.rb#841
  def set_form(params, enctype = T.unsafe(nil), formopt = T.unsafe(nil)); end

  # Set header fields and a body from HTML form data.
  # +params+ should be an Array of Arrays or
  # a Hash containing HTML form data.
  # Optional argument +sep+ means data record separator.
  #
  # Values are URL encoded as necessary and the content-type is set to
  # application/x-www-form-urlencoded
  #
  # Example:
  #
  #    http.form_data = {"q" => "ruby", "lang" => "en"}
  #    http.form_data = {"q" => ["ruby", "perl"], "lang" => "en"}
  #    http.set_form_data({"q" => "ruby", "lang" => "en"}, ';')
  #
  # Net::HTTPHeader#form_data= is an alias for Net::HTTPHeader#set_form_data.
  #
  # source://net-http//net/http/header.rb#781
  def set_form_data(params, sep = T.unsafe(nil)); end

  # call-seq:
  #   set_range(length) -> length
  #   set_range(offset, length) -> range
  #   set_range(begin..length) -> range
  #
  # Sets the value for field <tt>'Range'</tt>;
  # see {Range request header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#range-request-header]:
  #
  # With argument +length+:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req.set_range(100)      # => 100
  #   req['Range']            # => "bytes=0-99"
  #
  # With arguments +offset+ and +length+:
  #
  #   req.set_range(100, 100) # => 100...200
  #   req['Range']            # => "bytes=100-199"
  #
  # With argument +range+:
  #
  #   req.set_range(100..199) # => 100..199
  #   req['Range']            # => "bytes=100-199"
  #
  # Net::HTTPHeader#range= is an alias for Net::HTTPHeader#set_range.
  #
  # source://net-http//net/http/header.rb#568
  def set_range(r, e = T.unsafe(nil)); end

  # source://net-http//net/http/header.rb#200
  def size; end

  # Returns the trailing ('subtype') part of the
  # {media type}[https://en.wikipedia.org/wiki/Media_type]
  # from the value of field <tt>'Content-Type'</tt>,
  # or +nil+ if no such field exists;
  # see {Content-Type response header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-response-header]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res['content-type'] # => "application/json; charset=utf-8"
  #   res.sub_type        # => "json"
  #
  # source://net-http//net/http/header.rb#726
  def sub_type; end

  # Returns a hash of the key/value pairs:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req.to_hash
  #   # =>
  #   {"accept-encoding"=>["gzip;q=1.0,deflate;q=0.6,identity;q=0.3"],
  #    "accept"=>["*/*"],
  #    "user-agent"=>["Ruby"],
  #    "host"=>["jsonplaceholder.typicode.com"]}
  #
  # source://net-http//net/http/header.rb#469
  def to_hash; end

  # Returns the trailing ('parameters') part of the value of field <tt>'Content-Type'</tt>,
  # or +nil+ if no such field exists;
  # see {Content-Type response header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-response-header]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res['content-type'] # => "application/json; charset=utf-8"
  #   res.type_params     # => {"charset"=>"utf-8"}
  #
  # source://net-http//net/http/header.rb#741
  def type_params; end

  private

  # source://net-http//net/http/header.rb#277
  def append_field_value(ary, val); end

  # source://net-http//net/http/header.rb#865
  def basic_encode(account, password); end

  # source://net-http//net/http/header.rb#485
  def capitalize(name); end

  # source://net-http//net/http/header.rb#262
  def set_field(key, val); end
end

# source://net-http//net/http/responses.rb#23
Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError

# source://net-http//net/http/backward.rb#19
Net::HTTPInformationCode = Net::HTTPInformation

# Response class for <tt>Loop Detected (WebDAV)</tt> responses (status code 508).
#
# The server detected an infinite loop while processing the request.
# See {508 Loop Detected (WebDAV)}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#508].
class Net::HTTPLoopDetected < ::Net::HTTPServerError; end

# source://net-http//net/http/responses.rb#626
Net::HTTPLoopDetected::HAS_BODY = T.let(T.unsafe(nil), TrueClass)

# Response class for <tt>Misdirected Request</tt> responses (status code 421).
#
# The request was directed at a server that is not able to produce a response.
# See {421 Misdirected Request}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#421].
class Net::HTTPMisdirectedRequest < ::Net::HTTPClientError; end

# source://net-http//net/http/responses.rb#476
Net::HTTPMisdirectedRequest::HAS_BODY = T.let(T.unsafe(nil), TrueClass)

# source://net-http//net/http/responses.rb#267
Net::HTTPMovedTemporarily = Net::HTTPFound

# source://net-http//net/http/responses.rb#248
Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

# Response class for <tt>Not Extended</tt> responses (status code 510).
#
# Further extensions to the request are required for the server to fulfill it.
# See {510 Not Extended}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#510].
class Net::HTTPNotExtended < ::Net::HTTPServerError; end

# source://net-http//net/http/responses.rb#635
Net::HTTPNotExtended::HAS_BODY = T.let(T.unsafe(nil), TrueClass)

# Response class for <tt>Payload Too Large</tt> responses (status code 413).
#
# The request is larger than the server is willing or able to process.
# See {413 Payload Too Large}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#413].
class Net::HTTPPayloadTooLarge < ::Net::HTTPClientError; end

# source://net-http//net/http/responses.rb#427
Net::HTTPPayloadTooLarge::HAS_BODY = T.let(T.unsafe(nil), TrueClass)

# Response class for +Processing+ responses (status code 102).
#
# The +Processing+ response indicates that the server has received
# and is processing the request, but no response is available yet.
#
# References:
#
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#102].
class Net::HTTPProcessing < ::Net::HTTPInformation; end

# source://net-http//net/http/responses.rb#123
Net::HTTPProcessing::HAS_BODY = T.let(T.unsafe(nil), FalseClass)

# Response class for <tt>Range Not Satisfiable</tt> responses (status code 416).
#
# The request entity has a media type which the server or resource does not support.
# See {416 Range Not Satisfiable}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#416].
class Net::HTTPRangeNotSatisfiable < ::Net::HTTPClientError; end

# source://net-http//net/http/responses.rb#454
Net::HTTPRangeNotSatisfiable::HAS_BODY = T.let(T.unsafe(nil), TrueClass)

# source://net-http//net/http/responses.rb#53
Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

# source://net-http//net/http/backward.rb#21
Net::HTTPRedirectionCode = Net::HTTPRedirection

# source://net-http//net/http/responses.rb#439
Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

# Typo since 2001
#
# source://net-http//net/http/backward.rb#28
Net::HTTPResponceReceiver = Net::HTTPResponse

# This class is the base class for \Net::HTTP request classes.
#
# == About the Examples
#
# :include: doc/net-http/examples.rdoc
#
# == Returned Responses
#
# \Method Net::HTTP.get_response returns
# an instance of one of the subclasses of \Net::HTTPResponse:
#
#   Net::HTTP.get_response(uri)
#   # => #<Net::HTTPOK 200 OK readbody=true>
#   Net::HTTP.get_response(hostname, '/nosuch')
#   # => #<Net::HTTPNotFound 404 Not Found readbody=true>
#
# As does method Net::HTTP#request:
#
#   req = Net::HTTP::Get.new(uri)
#   Net::HTTP.start(hostname) do |http|
#     http.request(req)
#   end # => #<Net::HTTPOK 200 OK readbody=true>
#
# \Class \Net::HTTPResponse includes module Net::HTTPHeader,
# which provides access to response header values via (among others):
#
# - \Hash-like method <tt>[]</tt>.
# - Specific reader methods, such as +content_type+.
#
# Examples:
#
#   res = Net::HTTP.get_response(uri) # => #<Net::HTTPOK 200 OK readbody=true>
#   res['Content-Type']               # => "text/html; charset=UTF-8"
#   res.content_type                  # => "text/html"
#
# == Response Subclasses
#
# \Class \Net::HTTPResponse has a subclass for each
# {HTTP status code}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes].
# You can look up the response class for a given code:
#
#   Net::HTTPResponse::CODE_TO_OBJ['200'] # => Net::HTTPOK
#   Net::HTTPResponse::CODE_TO_OBJ['400'] # => Net::HTTPBadRequest
#   Net::HTTPResponse::CODE_TO_OBJ['404'] # => Net::HTTPNotFound
#
# And you can retrieve the status code for a response object:
#
#   Net::HTTP.get_response(uri).code                 # => "200"
#   Net::HTTP.get_response(hostname, '/nosuch').code # => "404"
#
# The response subclasses (indentation shows class hierarchy):
#
# - Net::HTTPUnknownResponse (for unhandled \HTTP extensions).
#
# - Net::HTTPInformation:
#
#   - Net::HTTPContinue (100)
#   - Net::HTTPSwitchProtocol (101)
#   - Net::HTTPProcessing (102)
#   - Net::HTTPEarlyHints (103)
#
# - Net::HTTPSuccess:
#
#   - Net::HTTPOK (200)
#   - Net::HTTPCreated (201)
#   - Net::HTTPAccepted (202)
#   - Net::HTTPNonAuthoritativeInformation (203)
#   - Net::HTTPNoContent (204)
#   - Net::HTTPResetContent (205)
#   - Net::HTTPPartialContent (206)
#   - Net::HTTPMultiStatus (207)
#   - Net::HTTPAlreadyReported (208)
#   - Net::HTTPIMUsed (226)
#
# - Net::HTTPRedirection:
#
#   - Net::HTTPMultipleChoices (300)
#   - Net::HTTPMovedPermanently (301)
#   - Net::HTTPFound (302)
#   - Net::HTTPSeeOther (303)
#   - Net::HTTPNotModified (304)
#   - Net::HTTPUseProxy (305)
#   - Net::HTTPTemporaryRedirect (307)
#   - Net::HTTPPermanentRedirect (308)
#
# - Net::HTTPClientError:
#
#   - Net::HTTPBadRequest (400)
#   - Net::HTTPUnauthorized (401)
#   - Net::HTTPPaymentRequired (402)
#   - Net::HTTPForbidden (403)
#   - Net::HTTPNotFound (404)
#   - Net::HTTPMethodNotAllowed (405)
#   - Net::HTTPNotAcceptable (406)
#   - Net::HTTPProxyAuthenticationRequired (407)
#   - Net::HTTPRequestTimeOut (408)
#   - Net::HTTPConflict (409)
#   - Net::HTTPGone (410)
#   - Net::HTTPLengthRequired (411)
#   - Net::HTTPPreconditionFailed (412)
#   - Net::HTTPRequestEntityTooLarge (413)
#   - Net::HTTPRequestURITooLong (414)
#   - Net::HTTPUnsupportedMediaType (415)
#   - Net::HTTPRequestedRangeNotSatisfiable (416)
#   - Net::HTTPExpectationFailed (417)
#   - Net::HTTPMisdirectedRequest (421)
#   - Net::HTTPUnprocessableEntity (422)
#   - Net::HTTPLocked (423)
#   - Net::HTTPFailedDependency (424)
#   - Net::HTTPUpgradeRequired (426)
#   - Net::HTTPPreconditionRequired (428)
#   - Net::HTTPTooManyRequests (429)
#   - Net::HTTPRequestHeaderFieldsTooLarge (431)
#   - Net::HTTPUnavailableForLegalReasons (451)
#
# - Net::HTTPServerError:
#
#   - Net::HTTPInternalServerError (500)
#   - Net::HTTPNotImplemented (501)
#   - Net::HTTPBadGateway (502)
#   - Net::HTTPServiceUnavailable (503)
#   - Net::HTTPGatewayTimeOut (504)
#   - Net::HTTPVersionNotSupported (505)
#   - Net::HTTPVariantAlsoNegotiates (506)
#   - Net::HTTPInsufficientStorage (507)
#   - Net::HTTPLoopDetected (508)
#   - Net::HTTPNotExtended (510)
#   - Net::HTTPNetworkAuthenticationRequired (511)
#
# There is also the Net::HTTPBadResponse exception which is raised when
# there is a protocol error.
class Net::HTTPResponse
  include ::Net::HTTPHeader

  # @return [HTTPResponse] a new instance of HTTPResponse
  #
  # source://net-http//net/http/response.rb#194
  def initialize(httpv, code, msg); end

  # Returns the full entity body.
  #
  # Calling this method a second or subsequent time will return the
  # string already read.
  #
  #   http.request_get('/index.html') {|res|
  #     puts res.body
  #   }
  #
  #   http.request_get('/index.html') {|res|
  #     p res.body.object_id   # 538149362
  #     p res.body.object_id   # 538149362
  #   }
  #
  # source://net-http//net/http/response.rb#379
  def body; end

  # Because it may be necessary to modify the body, Eg, decompression
  # this method facilitates that.
  #
  # source://net-http//net/http/response.rb#385
  def body=(value); end

  # The encoding to use for the response body. If Encoding, use that encoding.
  # If other true value, attempt to detect the appropriate encoding, and use
  # that.
  #
  # source://net-http//net/http/response.rb#230
  def body_encoding; end

  # Set the encoding to use for the response body.  If given a String, find
  # the related Encoding.
  #
  # source://net-http//net/http/response.rb#234
  def body_encoding=(value); end

  # The HTTP result code string. For example, '302'.  You can also
  # determine the response type by examining which response subclass
  # the response object is an instance of.
  #
  # source://net-http//net/http/response.rb#213
  def code; end

  # response <-> exception relationship
  #
  # source://net-http//net/http/response.rb#251
  def code_type; end

  # Set to true automatically when the request did not contain an
  # Accept-Encoding header from the user.
  #
  # source://net-http//net/http/response.rb#225
  def decode_content; end

  # Set to true automatically when the request did not contain an
  # Accept-Encoding header from the user.
  #
  # source://net-http//net/http/response.rb#225
  def decode_content=(_arg0); end

  # Returns the full entity body.
  #
  # Calling this method a second or subsequent time will return the
  # string already read.
  #
  #   http.request_get('/index.html') {|res|
  #     puts res.body
  #   }
  #
  #   http.request_get('/index.html') {|res|
  #     p res.body.object_id   # 538149362
  #     p res.body.object_id   # 538149362
  #   }
  #
  # source://net-http//net/http/response.rb#379
  def entity; end

  # @raise [error_type()]
  #
  # source://net-http//net/http/response.rb#255
  def error!; end

  # source://net-http//net/http/response.rb#261
  def error_type; end

  # source://net-http//net/http/response.rb#283
  def header; end

  # The HTTP version supported by the server.
  #
  # source://net-http//net/http/response.rb#208
  def http_version; end

  # Whether to ignore EOF when reading bodies with a specified Content-Length
  # header.
  #
  # source://net-http//net/http/response.rb#241
  def ignore_eof; end

  # Whether to ignore EOF when reading bodies with a specified Content-Length
  # header.
  #
  # source://net-http//net/http/response.rb#241
  def ignore_eof=(_arg0); end

  # source://net-http//net/http/response.rb#243
  def inspect; end

  # The HTTP result message sent by the server. For example, 'Not Found'.
  #
  # source://net-http//net/http/response.rb#216
  def message; end

  # The HTTP result message sent by the server. For example, 'Not Found'.
  #
  # source://net-http//net/http/response.rb#216
  def msg; end

  # Gets the entity body returned by the remote HTTP server.
  #
  # If a block is given, the body is passed to the block, and
  # the body is provided in fragments, as it is read in from the socket.
  #
  # If +dest+ argument is given, response is read into that variable,
  # with <code>dest#<<</code> method (it could be String or IO, or any
  # other object responding to <code><<</code>).
  #
  # Calling this method a second or subsequent time for the same
  # HTTPResponse object will return the value already read.
  #
  #   http.request_get('/index.html') {|res|
  #     puts res.read_body
  #   }
  #
  #   http.request_get('/index.html') {|res|
  #     p res.read_body.object_id   # 538149362
  #     p res.read_body.object_id   # 538149362
  #   }
  #
  #   # using iterator
  #   http.request_get('/index.html') {|res|
  #     res.read_body do |segment|
  #       print segment
  #     end
  #   }
  #
  # source://net-http//net/http/response.rb#336
  def read_body(dest = T.unsafe(nil), &block); end

  # source://net-http//net/http/response.rb#288
  def read_header; end

  # body
  #
  # source://net-http//net/http/response.rb#297
  def reading_body(sock, reqmethodallowbody); end

  # header (for backward compatibility only; DO NOT USE)
  #
  # source://net-http//net/http/response.rb#278
  def response; end

  # The URI used to fetch this response.  The response URI is only available
  # if a URI was used to create the request.
  #
  # source://net-http//net/http/response.rb#221
  def uri; end

  # source://net-http//net/http/response.rb#270
  def uri=(uri); end

  # Raises an HTTP error if the response is not 2xx (success).
  #
  # source://net-http//net/http/response.rb#266
  def value; end

  private

  # source://net-http//net/http/response.rb#430
  def check_bom(str); end

  # source://net-http//net/http/response.rb#394
  def detect_encoding(str, encoding = T.unsafe(nil)); end

  # source://net-http//net/http/response.rb#520
  def extracting_encodings_from_meta_elements(value); end

  # source://net-http//net/http/response.rb#485
  def get_attribute(ss); end

  # Checks for a supported Content-Encoding header and yields an Inflate
  # wrapper for this response's socket when zlib is present.  If the
  # Content-Encoding is not supported or zlib is missing, the plain socket is
  # yielded.
  #
  # If a Content-Range header is present, a plain socket is yielded as the
  # bytes in the range may not be a complete deflate block.
  #
  # source://net-http//net/http/response.rb#537
  def inflater; end

  # @raise [ArgumentError]
  #
  # source://net-http//net/http/response.rb#626
  def procdest(dest, block); end

  # source://net-http//net/http/response.rb#572
  def read_body_0(dest); end

  # read_chunked reads from +@socket+ for chunk-size, chunk-extension, CRLF,
  # etc. and +chunk_data_io+ for chunk-data which may be deflate or gzip
  # encoded.
  #
  # See RFC 2616 section 3.6.1 for definitions
  #
  # source://net-http//net/http/response.rb#602
  def read_chunked(dest, chunk_data_io); end

  # source://net-http//net/http/response.rb#444
  def scanning_meta(str); end

  # source://net-http//net/http/response.rb#414
  def sniff_encoding(str, encoding = T.unsafe(nil)); end

  # @raise [IOError]
  #
  # source://net-http//net/http/response.rb#622
  def stream_check; end

  class << self
    # true if the response has a body.
    #
    # @return [Boolean]
    #
    # source://net-http//net/http/response.rb#138
    def body_permitted?; end

    # source://net-http//net/http/response.rb#142
    def exception_type; end

    # source://net-http//net/http/response.rb#146
    def read_new(sock); end

    private

    # @yield [key, value]
    #
    # source://net-http//net/http/response.rb#170
    def each_response_header(sock); end

    # source://net-http//net/http/response.rb#157
    def read_status_line(sock); end

    # source://net-http//net/http/response.rb#164
    def response_class(code); end
  end
end

# Inflater is a wrapper around Net::BufferedIO that transparently inflates
# zlib and gzip streams.
class Net::HTTPResponse::Inflater
  # Creates a new Inflater wrapping +socket+
  #
  # @return [Inflater] a new instance of Inflater
  #
  # source://net-http//net/http/response.rb#645
  def initialize(socket); end

  # The number of bytes inflated, used to update the Content-Length of
  # the response.
  #
  # source://net-http//net/http/response.rb#663
  def bytes_inflated; end

  # Finishes the inflate stream.
  #
  # source://net-http//net/http/response.rb#654
  def finish; end

  # Returns a Net::ReadAdapter that inflates each read chunk into +dest+.
  #
  # This allows a large response body to be inflated without storing the
  # entire body in memory.
  #
  # source://net-http//net/http/response.rb#673
  def inflate_adapter(dest); end

  # Reads +clen+ bytes from the socket, inflates them, then writes them to
  # +dest+.  +ignore_eof+ is passed down to Net::BufferedIO#read
  #
  # Unlike Net::BufferedIO#read, this method returns more than +clen+ bytes.
  # At this time there is no way for a user of Net::HTTPResponse to read a
  # specific number of bytes from the HTTP response body, so this internal
  # API does not return the same number of bytes as were requested.
  #
  # See https://bugs.ruby-lang.org/issues/6492 for further discussion.
  #
  # source://net-http//net/http/response.rb#700
  def read(clen, dest, ignore_eof = T.unsafe(nil)); end

  # Reads the rest of the socket, inflates it, then writes it to +dest+.
  #
  # source://net-http//net/http/response.rb#709
  def read_all(dest); end
end

# source://net-http//net/http/backward.rb#26
Net::HTTPResponseReceiver = Net::HTTPResponse

# source://net-http//net/http/backward.rb#22
Net::HTTPRetriableCode = Net::HTTPRedirection

# source://net-http//net/http/responses.rb#81
Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

# source://net-http//net/http/backward.rb#25
Net::HTTPServerErrorCode = Net::HTTPServerError

# source://net-http//net/http/backward.rb#17
Net::HTTPSession = Net::HTTP

# source://net-http//net/http/responses.rb#38
Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

# source://net-http//net/http/backward.rb#20
Net::HTTPSuccessCode = Net::HTTPSuccess

# Response class for <tt>URI Too Long</tt> responses (status code 414).
#
# The URI provided was too long for the server to process.
# See {414 URI Too Long}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#414].
class Net::HTTPURITooLong < ::Net::HTTPClientError; end

# source://net-http//net/http/responses.rb#436
Net::HTTPURITooLong::HAS_BODY = T.let(T.unsafe(nil), TrueClass)

# source://net-http//net/http/responses.rb#9
Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

# Response class for <tt>Variant Also Negotiates</tt> responses (status code 506).
#
# Transparent content negotiation for the request results in a circular reference.
# See {506 Variant Also Negotiates}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#506].
class Net::HTTPVariantAlsoNegotiates < ::Net::HTTPServerError; end

# source://net-http//net/http/responses.rb#610
Net::HTTPVariantAlsoNegotiates::HAS_BODY = T.let(T.unsafe(nil), TrueClass)

# source://net-http//net/http/backward.rb#12
Net::NetPrivate::HTTPRequest = Net::HTTPRequest
